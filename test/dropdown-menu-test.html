<!doctype html>

<head>
  <meta charset="UTF-8">
  <title>vaadin-dropdown-menu tests</title>
  <script src="../../web-component-tester/browser.js"></script>
  <script src="../../iron-test-helpers/mock-interactions.js"></script>
  <link rel="import" href="../../vaadin-list-box/vaadin-list-box.html">
  <link rel="import" href="../../vaadin-item/vaadin-item.html">
  <link rel="import" href="../vaadin-dropdown-menu.html">
</head>

<body>
  <test-fixture id="dropdown">
    <template>
      <vaadin-dropdown-menu>
        <template>
          <vaadin-list-box>
            <vaadin-item>Option 1</vaadin-item>
            <vaadin-item label="o2">Option 2</vaadin-item>
            <vaadin-item> Option 3 </vaadin-item>
            <vaadin-item></vaadin-item>
          </vaadin-list-box>
        </template>
      </vaadin-dropdown-menu>
    </template>
  </test-fixture>

  <test-fixture id="notemplate">
    <template>
      <vaadin-dropdown-menu>
      </vaadin-dropdown-menu>
    </template>
  </test-fixture>

  <test-fixture id="nomenu">
    <template>
      <vaadin-dropdown-menu>
        <template>
        </template>
      </vaadin-dropdown-menu>
    </template>
  </test-fixture>

  <script>
    function arrowUp(target) {
      MockInteractions.keyDownOn(target, 38, [], 'ArrowUp');
    }
    function arrowDown(target) {
      MockInteractions.keyDownOn(target, 40, [], 'ArrowDown');
    }
    function Space(target) {
      MockInteractions.keyDownOn(target, 32, [], ' ');
    }
    function Enter(target) {
      MockInteractions.keyDownOn(target, 13, [], 'Enter');
    }
    function Tab(target) {
      MockInteractions.keyDownOn(target, 9, [], 'Tab');
    }
    function Escape(target) {
      MockInteractions.keyDownOn(target, 27, [], 'Escape');
    }

    describe('vaadin-dropdown-menu no-template', () => {
      var dropdown;
      beforeEach(() => dropdown = fixture('notemplate'));

      it('should not throw an exception if template is not present', () => {
        dropdown.opened = true;
        dropdown.value = 'foo';
        dropdown.opened = false;
      });

    });

    describe('vaadin-dropdown-menu no-menu', () => {
      var dropdown;
      beforeEach(() => dropdown = fixture('nomenu'));

      it('should not throw an exception if menu list is not present', () => {
        dropdown.opened = true;
        dropdown.value = 'foo';
        dropdown.opened = false;
      });
    });

    describe('vaadin-dropdown-menu', () => {
      var dropdown, input;

      beforeEach(() => {
        dropdown = fixture('dropdown');
        input = dropdown._inputElement;
      });

      it('should have a valid localName', () => {
        expect(dropdown.localName).to.be.equal('vaadin-dropdown-menu');
      });

      it('should have a modified template with a slot for selected', () => {
        const modifiedTemplate = dropdown._inputElement.constructor.template;
        expect(modifiedTemplate.content.querySelector('slot[name="selected"]')).to.be.ok;
      });

      describe('selection', () => {

        var menu;

        beforeEach(done => {
          dropdown.opened = true;
          menu = dropdown._menuElement;
          Polymer.RenderStatus.afterNextRender(menu, done);
        });

        it('Should close the overlay when selecting a new item', () => {
          menu.selected = 2;
          expect(dropdown._overlayElement.opened).to.be.false;
        });

        it('Should update selection slot with a clone of the selected item', () => {
          menu.selected = 2;
          const itemElement = menu._navItems[menu.selected];
          const valueElement = dropdown._selectionElement.firstChild;
          expect(valueElement).not.to.be.equal(itemElement);
          expect(valueElement.localName).to.be.equal(itemElement.localName);
          expect(valueElement.textContent).to.be.equal(itemElement.textContent);
        });

        it('Should update value with the textContent of the selected item', () => {
          menu.selected = 2;
          expect(dropdown.value).to.be.equal('Option 3');
        });

        it('Should remove tabindex when cloning the value element', () => {
          menu.selected = 2;
          const itemElement = menu._navItems[menu.selected];
          const valueElement = dropdown._selectionElement.firstChild;
          expect(itemElement.tabIndex).to.be.equal(0);
          expect(valueElement.hasAttribute('tabindex')).to.be.false;
        });

        it('Should update selection slot textContent with the selected item `label` value', () => {
          menu.selected = 1;
          expect(dropdown._selectionElement.textContent.trim()).to.be.equal('o2');
        });

        it('Should update value with the `label` value of the selected item', () => {
          menu.selected = 1;
          expect(dropdown.value).to.be.equal('o2');
        });

        it('Should update selection slot when value is provided', () => {
          // FIXME: when component supports setting value after #15
        });

        it('Should update overlay selected item when value is provided', () => {
          // FIXME: when component supports setting value after #15
        });

      });

      describe('opening the overlay', () => {

        it('should keep synchronized opened properties in overlay and dropdown', () => {
          dropdown.opened = true;
          expect(dropdown.opened).to.be.true;
          expect(dropdown._overlayElement.opened).to.be.true;

          dropdown.opened = false;
          expect(dropdown._overlayElement.opened).to.be.false;
          expect(dropdown.opened).to.be.false;
        });

        it('overlay should be opened on click event on input', () => {
          expect(dropdown._overlayElement.opened).to.be.false;

          input.dispatchEvent(new CustomEvent('click', {bubbles: true}));
          expect(dropdown._overlayElement.opened).to.be.true;
        });

        it('On ArrowUp Should open the overlay, not select any item, and keep opened', () => {
          arrowUp(input);
          expect(dropdown._overlayElement.opened).to.be.true;
        });

        it('On ArrowDown Should open the overlay, not select any item, and keep opened', () => {
          arrowDown(input);
          expect(dropdown._overlayElement.opened).to.be.true;
        });

        it('On Space Should open the overlay, not select any item, and keep opened', () => {
          Space(input);
          expect(dropdown._overlayElement.opened).to.be.true;
        });

        it('On Enter Should open the overlay, not select any item, and keep opened', () => {
          Enter(input);
          expect(dropdown._overlayElement.opened).to.be.true;
        });

        it('On Escape Should close the overlay', () => {
          dropdown.opened = true;

          Escape(input);
          expect(dropdown._overlayElement.opened).to.be.false;
        });

        it('should open the overlay on top left corner by default on input click', () => {
          Enter(input);
          expect(dropdown._overlayElement.getBoundingClientRect().top).to.be.equal(input.getBoundingClientRect().top);
          expect(dropdown._overlayElement.getBoundingClientRect().left).to.be.equal(input.getBoundingClientRect().left);
        });

      });

      describe('disabled', () => {
        it('should disable the input and disable opening if dropdown-menu is disabled', () => {
          dropdown.disabled = true;

          expect(input.disabled).to.be.true;

          Enter(input);
          expect(dropdown._overlayElement.opened).to.be.false;

          input.dispatchEvent(new CustomEvent('click', {bubbles: true}));
          expect(dropdown._overlayElement.opened).to.be.false;
        });
      });

      describe('focus', () => {

        it('Should be focusable', () => {
          // FIXME: The element is not focusable yet. Uncomment after fixing #14
          // dropdown.focus();
          // expect(dropdown.focused).to.be.true;
          // expect(input.focused).to.be.true;
        });

        it('Should focus the next focusable element when tabbing', () => {
          // We should use here dropdown.focus(), but need to fix after #14
          input.focus();
          expect(input.focused).to.be.true;

          // Tabbing does not nativelly move the focus, hence we only can check that the event is not prevented
          const ev = MockInteractions.keyboardEventFor(9, [], 'Tab');
          input.dispatchEvent(ev);
          expect(ev.defaultPrevented).to.be.false;
        });

        it('Should focus the previous element when shift tabbing', () => {
          // We should use here dropdown.focus(), but need to fix after #14
          input.focus();
          expect(input.focused).to.be.true;

          // Tabbing does not nativelly move the focus, hence we only can check that the event is not prevented
          const ev = MockInteractions.keyboardEventFor(9, ['shift'], 'Tab');
          input.dispatchEvent(ev);
          expect(ev.defaultPrevented).to.be.false;
        });
      });

      describe('overlay opened', () => {
        var menu;

        beforeEach(done => {
          Enter(input);
          menu = dropdown._menuElement;
          Polymer.RenderStatus.afterNextRender(menu, done);
        });

        it('should close the dropdown-menu on selecting the same value', () => {
          menu.selected = 0;
          expect(dropdown.value).to.be.equal(menu._navItems[0].textContent);
          expect(dropdown._overlayElement.opened).to.be.false;

          Enter(input);
          expect(dropdown._overlayElement.opened).to.be.true;
          menu._navItems[0].dispatchEvent(new CustomEvent('click', {bubbles: true}));
          expect(dropdown.value).to.be.equal(menu._navItems[0].textContent);
          expect(dropdown._overlayElement.opened).to.be.false;
        });

        it('should focus the input on selecting value and closing the overlay', () => {
          const focusedSpy = sinon.spy();
          dropdown.focusElement.focus = focusedSpy;

          menu.selected = 0;
          expect(dropdown.value).to.be.equal(menu._navItems[0].textContent);
          expect(dropdown._overlayElement.opened).to.be.false;

          expect(focusedSpy).to.be.calledOnce;
        });

        it('should focus the input before moving the focus to next selectable element', () => {
          const focusedSpy = sinon.spy();
          dropdown.focusElement.focus = focusedSpy;

          Tab(menu);
          expect(focusedSpy).to.be.calledOnce;
        });

        it('Should hidde native input when selecting an item', () => {
          menu.selected = 1;
          expect(input.focusElement.style.opacity).to.be.equal('0');

        });

        it('Should show native input when value is empty', () => {
          menu.selected = 1;

          menu.selected = 3;
          expect(input.focusElement.style.opacity).to.be.equal('1');
        });

        it('Should close the overlay when clicking on the overlay', () => {
          dropdown.opened = false;
          dropdown._overlayElement.click();
          expect(dropdown.opened).to.be.false;
        });
      });

      describe('aria', () => {
        it('should have aria-required attribute set to true when required', () => {
          dropdown.setAttribute('required', '');
          expect(dropdown.getAttribute('aria-required')).to.be.equal('true');
        });

        it('should have aria-disabled attribute set to true when disabled', () => {
          dropdown.setAttribute('disabled', '');
          expect(dropdown.getAttribute('aria-disabled')).to.be.equal('true');
        });

        it('should have aria-hidden attribute to the native input', () => {
          expect(dropdown._nativeInput.getAttribute('aria-hidden')).to.be.equal('true');
        });
      });

      describe('validation', () => {
        it('should have invalid attribute when is required but there is no value', () => {
          expect(dropdown.hasAttribute('invalid')).to.be.false;
          dropdown.setAttribute('required', '');

          Enter(input);
          Escape(input);
          expect(dropdown.hasAttribute('invalid')).to.be.true;
        });

        it('should not have invalid attribute when is required, there is no value, but is disabled', () => {
          expect(dropdown.hasAttribute('invalid')).to.be.false;
          dropdown.setAttribute('required', '');
          dropdown.setAttribute('disabled', '');

          dropdown.validate();
          expect(dropdown.hasAttribute('invalid')).to.be.false;
        });

        it('Should validate when closing the overlay', () => {
          const spy = sinon.spy();
          dropdown.validate = spy;
          dropdown.opened = true;

          dropdown.opened = false;
          expect(spy).to.be.calledOnce;
        });

      });

    });
  </script>
</body>
